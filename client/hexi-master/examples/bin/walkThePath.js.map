{"version":3,"sources":["../src/walkThePath.js"],"names":[],"mappings":"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","file":"walkThePath.js","sourcesContent":["/*\nA demonstration of how to use Hexi's `shortestPath` function to help you create\na game character that can navigate a maze\n*/\n\nlet thingsToLoad = [\n  \"images/timeBombPanic.png\",\n  \"maps/walkThePath.json\"\n];\n\n//Create a new Hexi instance, and start it.\nlet g = hexi(832, 768, setup, thingsToLoad);\n\n//Set the background color and scale the canvas\n//g.backgroundColor = \"black\";\ng.scaleToWindow();\n\n//Start Hexi\ng.start();\n\n//Game variables\nlet alien, wayPoints2DArray, calculateNewPath,\n  destinationX, destinationY, world, wallMapArray;\n\n//The `setup` function to initialize your application\nfunction setup() {\n\n  //Make the world from the Tiled JSON data and the tileset PNG image\n  world = g.makeTiledWorld(\n    \"maps/walkThePath.json\",\n    \"images/timeBombPanic.png\"\n  );\n\n  //Create the alien sprite \n  alien = world.getObject(\"alien\");\n\n  //Create the bomb sprite\n  //bomb = world.getObject(\"bomb\");\n\n  //Get a reference to the array that stores all the wall data\n  wallMapArray = world.getObject(\"wallLayer\").data;\n\n  //An array that will be used to store sub-arrays of \n  //x/y position value pairs that we're going to use\n  //to change the velocity of the alien sprite\n  wayPoints2DArray = [];\n\n  //A Boolean that will be set to true when the pointer\n  //is clicked, and set to false when the new path\n  //is calculated\n  calculateNewPath = false;\n\n\n  //The mouse pointer's `release` function runs the code that\n  //calculates the shortest path and draws that sprites that\n  //represent it\n  g.pointer.release = () => {\n\n    //Set the new path's desination to the pointer's\n    //current x and y position\n    destinationX = g.pointer.x;\n    destinationY = g.pointer.y;\n\n    //Set `calculateNewPath` to true\n    calculateNewPath = true;\n  };\n\n\n  //Change the game state to `play` to start the game loop\n  g.state = play;\n}\n\nfunction play() {\n\n  //Find out if the alien is centered over a tile cell \n  if (isCenteredOverCell(alien)) {\n\n    //If `calculateNewPath` has been set to `true` by the pointer,\n    //Find the new shortest path between the alien and the pointer's\n    //x and y position (`destinationX` and `destinationY`)\n    if (calculateNewPath) {\n\n      //calculate the shortest path\n      let path = g.shortestPath(\n        g.getIndex(alien.centerX, alien.centerY, 64, 64, 13), //The start map index\n        g.getIndex(destinationX, destinationY, 64, 64, 13), //The destination index\n        wallMapArray, //The map array\n        13, //Map width, in tiles\n        [2, 3], //Obstacle gid array\n        \"manhattan\", //Heuristic to use\n        false //Use diagonals (true) or only use orthogonally adjacent tiles (false)\n      );\n\n      //Remove the first node of the `path` array. That's because we\n      //don't need it: the alien sprite's current location and the\n      //first node in the `path` array share the same location.\n      //In the code ahead we're going to tell the alien sprite to move\n      //from its current location, to first new node in the path.\n      path.shift();\n\n      //If the path isn't empty, fill the `wayPoints2DArray` with\n      //sub arrays of x/y position value pairs. \n      if (path.length !== 0) {\n\n        //Get a 2D array of x/y points\n        wayPoints2DArray = path.map(node => {\n\n          //Figure out the x and y location of each square in the path by\n          //multiplying the node's `column` and `row` by the height, in\n          //pixels, of each cell: 64 \n          let x = node.column * 64,\n            y = node.row * 64;\n\n          //Return a sub-array containing the x and y position of each node\n          return [x, y];\n        });\n      }\n\n      //Set `calculateNewPath` to `false` so that this block of code.\n      //won't run again inside the game loop. (It can be set to `true`\n      //again by clicking the pointer.) \n      calculateNewPath = false;\n    }\n\n    //Set the alien's new velocity based on \n    //the alien's relative x/y position to the current, next, way point. \n    //Because we are always going to \n    //remove a way point element after we set this new \n    //velocity, the first element in the `wayPoints2DArray`\n    //will always refer to the next way point that the \n    //alien sprite has to move to  \n    if (wayPoints2DArray.length !== 0) {\n\n      //Left\n      if (wayPoints2DArray[0][0] < alien.x) {\n        alien.vx = -4;\n        alien.vy = 0;\n\n        //Right\n      } else if (wayPoints2DArray[0][0] > alien.x) {\n        alien.vx = 4;\n        alien.vy = 0;\n\n        //Up\n      } else if (wayPoints2DArray[0][1] < alien.y) {\n        alien.vx = 0;\n        alien.vy = -4;\n\n        //Down\n      } else if (wayPoints2DArray[0][1] > alien.y) {\n        alien.vx = 0;\n        alien.vy = 4;\n      }\n\n      //Remove the current way point, so that next time around\n      //the first element in the `wayPoints2DArray` will correctly refer\n      //to the next way point that that alien sprite has\n      //to move to\n      wayPoints2DArray.shift();\n\n      //If there are no way points remaining, \n      //set the alien's velocity to 0\n    } else {\n      alien.vx = 0;\n      alien.vy = 0;\n    }\n  }\n\n  //Move the alien based on the new velocity\n  alien.x += alien.vx;\n  alien.y += alien.vy;\n}\n\n//Helper functions\n//`isCenteredOverCell` returns true or false depending on whether a \n//sprite is exactly aligned to an intersection in the maze corridors\nfunction isCenteredOverCell(sprite) {\n  return Math.floor(sprite.x) % world.tilewidth === 0 && Math.floor(sprite.y) % world.tileheight === 0\n}\n"]}